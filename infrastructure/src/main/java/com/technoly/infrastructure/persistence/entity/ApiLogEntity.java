package com.technoly.infrastructure.persistence.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.JdbcTypeCode;
import org.hibernate.type.SqlTypes;

import java.time.LocalDateTime;

/**
 * API Log JPA Entity
 *
 * Stores the request and response details of every REST API call in PostgreSQL.
 * Both request and response are kept in JSON format in a JSONB column.
 *
 * Why JSONB?
 * 1. Flexible schema: Request/response structure can change without requiring
 * migration
 * 2. PostgreSQL index support: GIN index can be created on JSONB fields
 * 3. Query support: JSON path queries can be performed in the WHERE clause
 * Example: SELECT * FROM api_logs WHERE request->>'origin' = 'IST'
 * 4. Better performance compared to TEXT (parsed binary format)
 *
 * @Entity: Hibernate manages this class as a database table
 * @Table: Table name and index definitions
 * @Column(columnDefinition = "jsonb"): PostgreSQL JSONB type
 */
@Data
@Builder
@Entity
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "api_logs", indexes = {
        // Index on created_at: performance for time range queries
        @Index(name = "idx_api_logs_created_at", columnList = "created_at"),
        // Index on endpoint: for endpoint-specific queries
        @Index(name = "idx_api_logs_endpoint", columnList = "endpoint")
})
public class ApiLogEntity {

    /**
     * Primary Key: PostgreSQL BIGSERIAL (auto-increment BigInteger).
     * IDENTITY strategy: Generated by DB, JPA just reads it.
     * Why BIGSERIAL instead of UUID? â†’ Sequence is more performant,
     * and more suitable for sequential inserts.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Called REST endpoint: e.g. "/api/v1/flights/search"
     * nullable=false: Endpoint is mandatory in every log record.
     */
    @Column(name = "endpoint", nullable = false, length = 255)
    private String endpoint;

    /**
     * HTTP request body/params in JSON format.
     * @JdbcTypeCode(SqlTypes.JSON): Hibernate 6 selects the appropriate JSON type
     * for the database.
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "request", nullable = false)
    private String request;

    /**
     * HTTP response body in JSON format.
     * nullable=true: There might be no response in case of error.
     */
    @JdbcTypeCode(SqlTypes.JSON)
    @Column(name = "response")
    private String response;

    /** HTTP status code: 200, 400, 500 etc. */
    @Column(name = "status_code")
    private Integer statusCode;

    /** Processing duration (milliseconds): for performance tracking */
    @Column(name = "duration_ms")
    private Long durationMs;

    /**
     * Record creation time.
     * updatable=false: This field is set once and never updated.
     * 
     * Set automatically via @PrePersist.
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    /** Automatically sets the timestamp before JPA persist */
    @PrePersist
    protected void onCreate() {
        this.createdAt = LocalDateTime.now();
    }
}
